# RabbitMQ 基本开发

## 交换器与队列建立方案

- 交换器的使用不耗费服务器性能，但建立的队列会对服务器占用内存与流量，并耗费服务器的硬件资源

- 对于已确定的队列，无需在生产者或消费者里进行创建队列；只需使用RabbitMQ命令行在服务器创建好队列，并对交换器和队列进行正确地绑定匹配

- 若保持业务程序的灵活性，才需在业务程序中声明队列

## 消费模式

消费模式分为两种方式: Push模式[持续订阅] Pull模式[单次消费]

### Push模式

1. 服务端主动发送数据给客户端

2. 使用函数`basicConsume`处理消费消息; 设置回调方法处理业务; 消费业务被分配到Channel 的不同线程池上，不影响消费客户端的其他调用方法

3. 阻塞特性: Channel的一个消费者一直在运行, 其他消费者的回调消费会被一直阻塞

4. 持续订阅并消费所推送的消息；消息个数受`Basic.Qos`配置影响

#### 优缺点及业务分析

- 优点

1. 实时性高 服务端Broker获取消息会立即投递给消费者

- 缺点

1. 消息保存在服务端broker，容易造成消息堆积。

2. 依据订阅者消费能力做流控(流转机制); 消息个数受`Basic.Qos`配置影响 设置Qos，对服务端Borker提前表明消费端的消费能力，这样服务端最多推送指定数量的消息给消费者

3. 服务端broker需要维护每次传输状态，遇到问题需要重试; 需要保存push状态，哪些客户端已经发送成功，哪些发送失败

### Pull 模式

1. 客户端主动从服务端拉取数据

2. 单条消息进行消费；具备非阻塞性

3. 若以不断循环来实现持续消费消息，会影响性能

#### 优缺点及业务分析

- 优点

1. 状态维护在Consumer; 传输失败可以进行二次拉取

2. 消费端可以根据自身消费能力决定是否pull(流转机制) 

- 缺点

1. 默认的短轮询方式的实时性依赖于pull间隔时间，间隔越大，实时性越低

## 延时队列建立与消费

### 原理

- 延时的时长可作为消息的生存有效时长；通过放置消息在指定队列里；

- 将延时队列配置消息过期时所转发的消息队列里，当消息达到时长，则会被发送待消费的延时队列里

- 配置消费者处理因消息失效而被转发的消息队列里，从而实现延时业务处理

### 细节

#### 设置理论

1. 单一消息体进行配置其有效时长: 消息对象里配置`expiration`属性, 单位是`毫秒`; 消息是否过期是在即将投递到消费者之前进行判定的   **[此配置无法实现延时队列]**

2. 若有不同时长的延时业务需求，需要声明不同时长的队列，并且设置死信队列，来处理不同延时时长的业务

3. 队列声明，统一设置消息过期时间；消息进入到队列，延时长度是一致的; 消息一旦过期，会直接从队列里转移到死信队列[dead-letter-message]

4. 相应的消息过期时, 转存到相应的死信队列(延时队列)中, 消费者基于业务情况, 分别选择对应的延时级别队列进行消费

5. 消息的过期时间必须是非负32位整数 [0<= n <=4294967295]；当所设置的过期时长超过上述数值， 则无法实现延时消息

#### 配置流程

- `x-message-ttl`进行配置消息延时时长，单位是`毫秒`
- `x-dead-letter-exchange` 与 `x-dead-letter-routing-key` 配置死信交换器及路由键
- 声明一个队列与死信交换器进行绑定, 作为消费延时消息的消费者
