# RabbitMQ 基本开发

## 交换器与队列建立方案

- 交换器的使用不耗费服务器性能，但建立的队列会对服务器占用内存与流量，并耗费服务器的硬件资源

- 对于已确定的队列，无需在生产者或消费者里进行创建队列；只需使用RabbitMQ命令行在服务器创建好队列，并对交换器和队列进行正确地绑定匹配

- 若保持业务程序的灵活性，才需在业务程序中声明队列

## 消费模式

消费模式分为两种方式: Push模式[持续订阅] Pull模式[单次消费]

### Push模式

1. 使用函数`basicConsume`处理消费消息; 设置回调方法处理业务; 消费业务被分配到Channel 的不同线程池上，不影响消费客户端的其他调用方法

2. 阻塞特性: Channel的一个消费者一直在运行, 其他消费者的回调消费会被一直阻塞

3. 持续订阅并消费所推送的消息；消息个数受`Basic.Qos`配置影响

### Pull 模式

1. 单条消息进行消费；具备非阻塞性

2. 若以不断循环来实现持续消费消息，会影响性能

## 延时队列建立与消费

### 原理

- 延时的时长可作为消息的生存有效时长；通过放置消息在指定队列里；

- 将延时队列配置消息过期时所转发的消息队列里，当消息达到时长，则会被发送待消费的延时队列里

- 配置消费者处理因消息失效而被转发的消息队列里，从而实现延时业务处理

### 细节

#### 设置理论

1. <h5>[此配置无法实现延时队列]</h5>  单一消息体进行配置其有效时长: 消息对象里配置`expiration`属性, 单位是`毫秒`; 消息是否过期是在即将投递到消费者之前进行判定的

2. 若有不同时长的延时业务需求，需要声明不同时长的队列，并且设置死信队列，来处理不同延时时长的业务

3. 队列声明，统一设置消息过期时间；消息进入到队列，延时长度是一致的; 消息一旦过期，会直接从队列里转移到死信队列[dead-letter-message]

4. 相应的消息过期时, 转存到相应的死信队列(延时队列)中, 消费者基于业务情况, 分别选择对应的延时级别队列进行消费

#### 配置流程

- `x-message-ttl`进行配置消息延时时长，单位是`毫秒` 
- `x-dead-letter-exchange` 与 `x-dead-letter-routing-key` 配置死信交换器及路由键
- 声明一个队列与死信交换器进行绑定, 作为消费延时消息的消费者
