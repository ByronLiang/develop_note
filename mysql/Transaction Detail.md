# 事务要素及隔离级别总结

## 事务的基本要素

### ACID

1. 原子性(Atomicity) 事务执行过程中出错, 会回滚到事务的开始状态
2. 一致性(Consistency) 事务开始前与结束后，数据库完整性没有被破坏
3. 隔离性(Isolation) 不同事务之间彼此没有任何干扰
4. 持久性 事务完成后，不能出现回滚

#### 事务实现

日志优先存入到文件缓冲区，事务提交，再重刷进入磁盘

1. Redo日志: 在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据; 实现持久性

2. Undo日志: 发生错误或者需要回滚的事务能够成功回滚，主要是执行相反操作的语句；实现原子性

## 并发问题

1. 脏读：发生读取了已回滚数据；`事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据`

2. 不可重复读: 事务过程中，不同时段重复读取数据出现不一致 `事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致`

3. 幻读: 数据表出现新增/减少相关数据

总结：
- 不可重复读现象是数据修改问题，通过锁行进行处理；
- 幻读现象是数据的新增与删除；通过锁表可以避免出现；

## 事务隔离级别

### READ-UNCOMMITTED(读取未提交)

读取尚未事务提交的数据；容易引发脏读、幻读与不可重读

### READ-COMMITTED(读取已提交)

允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

### REPEATABLE-READ(可重读)

对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

### SERIALIZABLE(可串行化)

所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

#### 总结

- 隔离级别越低，事务请求的锁越少
- MySQL 默认使用的级别是REPEATABLE-READ（可重读）
- 查询: `SELECT @@tx_isolation`
- 设置: 
`SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]`

#### 补充

- 数据持久化服务处理并发机制

1. MySQl 使用排他锁(悲观锁)、乐观锁
2. ElasticSearch 可通过数据版本号进行校验处理

## MVCC 多版本并发控制

### 原理

InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较

### 应用

MVCC只在`COMMITTED READ`和 `REPEATABLE READ`两种事务隔离级别下工作。


