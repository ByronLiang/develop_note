# Insert into ... select 迁移表的注意事项

对表进行迁移，可通过`insert…select…limit N` 语句分片拷贝数据到目的表; 但若对select语句不正确处理, 会引发因全表扫描而引发锁表

## 情景

语句：`insert into table1 ...select * from table2：table1锁表，table2逐步锁（扫描一个锁一个）`

### 原因

- 后面的select语句对后表会逐步加共享锁(`share-lock`); 当此表正在进行更新操作时，使用排他锁(`x-lock`), 因行级数据被加共享锁，处于等待状态
- 行级数据会因迁移表数据命令(共享锁)与更新数据(排他锁)造成死锁情况：两个事务相互等待对方释放锁，导致事务永远无法终止的情况

### 解决

- 迁移表数据避免全表扫描, 对具有索引字段进行索引查询，只对部分数据进行加锁处理；
- InnoDB存储引擎死锁检测, 会强制对某一事务进行回滚操作，解除相关锁, 令另一事务正常进行

## 总结

- select默认不加行锁，如果不走索引默认使用表锁；使用select加行锁方法: `for update(排他锁)` `lock in share mode()共享锁)`

- 减少死锁：
    1. 固定顺序访问表和行;避免交叉等待锁的情景，事务顺序调整为一致；
    2. 事务拆分；减少事务里进行的数据处理流程；
    3. 添加合理的索引，避免对表里的每一行记录加上锁

## update语句使用锁情况

1. 对索引字段进行限制并完成更新操作，是一种行级锁；
`update table set xx = zz where 索引字段 = aa;` 对非此行级的数据进行更新操作不受影响

2. 对非索引字段进行限制并完成更新操作，会触发表级锁; 
`update table set xx = zz where 非索引字段 = aa;` 触发表级锁, 其余涉及此表的更新操作都处于阻塞状态

3. 对索引字段进行复杂限制(嵌套子查询)/不确定性限制并完成更新操作，同样触发表级锁;
`update table set xx = zz where 索引字段 in (select xx from table where aa = bb);` 嵌套子查询具有一定的不确定性，更新操作会进行表锁处理

### 补充

1. `insert`操作不具备锁;

2. `delete`与`update`语句具备相同使用锁的情况

### 锁的应用场景总结

1. 对于高并发场景, 若多线程请求下, 因为锁而导致阻塞, 会占用MySQL的连接数, 易引发其他读业务

2. 乐观锁一般适用多读少写场景, 主要确保跨数据表的一致性问题; 和实现CAS场景

```mysql
SELECT stock.number FROM stock WHERE id={id};
UPDATE stock SET number=number-1 WHERE id={id} AND number={number};
```

3. 悲观锁涉及同一表的相关更新操作; 写多读少场景;

4. 只要更新数据是依赖读取的数据作为基础条件的，就会有并发更新问题，需要乐观锁或者悲观锁取解决，特别实在计数表现明显; 在更新数据不依赖查询的数据的就不会有问题，例如修改用户的名称，多人同时修改，结果并不依赖于之前的用户名字

