# Insert into ... select 迁移表的注意事项

对表进行迁移，可通过`insert…select…limit N` 语句分片拷贝数据到目的表; 但若对select语句不正确处理, 会引发因全表扫描而引发锁表

## 情景

语句：`insert into table1 ...select * from table2：table1锁表，table2逐步锁（扫描一个锁一个）`

### 原因

- 后面的select语句对后表会逐步加共享锁(`share-lock`); 当此表正在进行更新操作时，使用排他锁(`x-lock`), 因行级数据被加共享锁，处于等待状态
- 行级数据会因迁移表数据命令(共享锁)与更新数据(排他锁)造成死锁情况：两个事务相互等待对方释放锁，导致事务永远无法终止的情况

### 解决

- 迁移表数据避免全表扫描, 对具有索引字段进行索引查询，只对部分数据进行加锁处理；
- InnoDB存储引擎死锁检测, 会强制对某一事务进行回滚操作，解除相关锁, 令另一事务正常进行

## 总结

- select默认不加行锁，如果不走索引默认使用表锁；使用select加行锁方法: `for update(排他锁)` `lock in share mode()共享锁)`

- 减少死锁：
    1. 固定顺序访问表和行;避免交叉等待锁的情景，事务顺序调整为一致；
    2. 事务拆分；减少事务里进行的数据处理流程；
    3. 添加合理的索引，避免对表里的每一行记录加上锁

## update语句使用锁情况

1. 对索引字段进行限制并完成更新操作，是一种行级锁；
`update table set xx = zz where 索引字段 = aa;` 对非此行级的数据进行更新操作不受影响

2. 对非索引字段进行限制并完成更新操作，会触发表级锁; 
`update table set xx = zz where 非索引字段 = aa;` 触发表级锁, 其余涉及此表的更新操作都处于阻塞状态

3. 对索引字段进行复杂限制(嵌套子查询)/不确定性限制并完成更新操作，同样触发表级锁;
`update table set xx = zz where 索引字段 in (select xx from table where aa = bb);` 嵌套子查询具有一定的不确定性，更新操作会进行表锁处理

### 补充

1. `insert`操作不具备锁;

2. `delete`与`update`语句具备相同使用锁的情况

