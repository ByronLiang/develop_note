# Insert into ... select 迁移表的注意事项

对表进行迁移，可通过`insert…select…limit N` 语句分片拷贝数据到目的表; 但若对select语句不正确处理, 会引发因全表扫描而引发锁表

## 情景

语句：`insert into table1 ...select * from table2：table1锁表，table2逐步锁（扫描一个锁一个）`

### 原因

- 后面的select语句对后表会逐步加共享锁(`share-lock`); 当此表正在进行更新操作时，使用排他锁(`x-lock`), 因行级数据被加共享锁，处于等待状态
- 行级数据会因迁移表数据命令(共享锁)与更新数据(排他锁)造成死锁情况：两个事务相互等待对方释放锁，导致事务永远无法终止的情况

### 解决

- 迁移表数据避免全表扫描, 对具有索引字段进行索引查询，只对部分数据进行加锁处理；
- InnoDB存储引擎死锁检测, 会强制对某一事务进行回滚操作，解除相关锁, 令另一事务正常进行

## 总结

- select默认不加行锁，如果不走索引默认使用表锁；使用select加行锁方法: `for update(排他锁)` `lock in share mode()共享锁)`

- 减少死锁：
    1. 固定顺序访问表和行;避免交叉等待锁的情景，事务顺序调整为一致；
    2. 事务拆分；减少事务里进行的数据处理流程；
    3. 添加合理的索引，避免对表里的每一行记录加上锁

