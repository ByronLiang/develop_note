# Redis 基本笔记

## 基本理论

- Redis实例对应多个db (默认16个) 每个db对应多个key,每个key对应一个value (数据结构：string[字符串]、list[列表]、map/hash[哈希]、set[集合]、sorted-set[有序集合])

- 通常以":"作为分隔符，将命名空间值和业务key连接

- list、Map、Set与sorted-set 的内存数据结构都具备ziplist[特殊编码的双向链表]特性

### pipeline模式提升吞吐量

Redis服务器采用TCP协议; 可将请求数据批量发送到服务器，再批量地从服务器连接的字节流中依次读取每个响应数据，提高单连接吞吐量；

### 入队/执行分离的事务原子性

- 客户端请求发送到服务器，暂存请求队列中；
- 服务器仅单线程地依次执行连接对象队列中的所有请求，期间不会执行其他客户端的请求
- 只读操作放在批量执行中没意义：结果不会改变事务的执行行为, 也不会改变Redis的数据状态；入队的请求应该是写操作；

#### 事务交互模式

- 四类请求
    1. 监听相关(watch、unwatch)
    2. 只读、写请求的批量执行或放弃执行请求(exec/discard)
    3. 写请求的入队(multi/exec/discard)

- 交互时序
    1. 开启对读写主键的监听、只读操作；
    2. multi请求
    3. 只读操作结果编排/参数赋值/入队写操作
    4. 一次性批量执行队列中的写请求

- 一旦两次读操作获取的值不一致, watch机制触发，拒绝后续的exec执行；
- Redis的执行器是单线程，写操作的执行本身就是通过串行的方式实现的可串行化；

### redis阻塞原因

底层原理: 

1. redis采用单线程处理请求;

2. I/O 多路复用程序负责监听多个套接字, 并向文件事件分派器传送那些产生了事件的套接字; 尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字

3. 一旦某个客户端的某个命令执行时间很长(big key情况)，就会阻塞其他客户端

### redis订阅模式不发生阻塞原因

客户端进行发起订阅时, redis会新开一个连接处理订阅channel的监听; 不会对其他客户端的使用产生阻塞;

#### 集群Pub/Sub订阅处理

集群环境下, 实例间能跨节点进行channel的订阅; 

在集群模式中，发布者发布消息后的返回值取决于订阅者与发布者在不在同一个节点上：

发布者发布消息后返回值为与发布者相同节点当前订阅了该频道的客户端数量。

### expire过期设置

- 对key设置疏散且随机的过期时间；避免发送缓存雪崩，集中大量的key过期

### 大key的DEL操作

因redis是使用单线程，下述行为会发生较长时间的阻塞情况; 导致其他请求访问缓慢

- DEL命令删除体积较大的键， 又或者在使用 FLUSHDB 和 FLUSHALL 删除包含大量键的数据库

- 清理过期数据和淘汰内存超限的大体积数据

#### 解决

lazyfree机制: 删除键或数据库的操作放在后台线程`(lazyfree线程)`里执行, 达到异步删除效果，尽可能地避免服务器阻塞

redis.conf文件配置如下: 默认是使用同步删除，若配置为`yes` 则进行异步删除
```shell
# 内存满下的LRU策略：驱逐key
lazyfree-lazy-eviction no
# key过期
lazyfree-lazy-expire no
# del删除命令
lazyfree-lazy-server-del no
# flush db 操作
replica-lazy-flush no
```
