# Cache Category and Design Model

## 缓存分类

### 对象层次区分

- 本地缓存/进程内缓存

1. 应用服务器本地的缓存模式(JVM); 本地缓存称为进程内的缓存，进程内缓存直接访问进程内的所属内存，无需做进程间的通信，速度最快。
2. 本地缓存可分为堆内缓存与堆外缓存；堆内缓存对回收机制影响大，堆2外缓存又会增加额外的序列化和反序列化的开销；

- 进程间缓存

1. 进程内缓存过大，未避免启动过慢，可启动独立进程存放缓存，利用Domain Socket通信

- 远程缓存

1. 跨服务器访问缓存；数据存放在单独的缓存服务器(Memcached, Redis)

- 二级缓存

1. 本地缓存和远程缓存的结合；对于大量易变数据，采用散列到分布式的远程缓存，减少DB层访问；
2. 对于不易改变但访问量巨大的数据，可以放置于本地缓存；
3. 应用环境：在商城系统里，对于品牌、分类的数据，可以设立一个版本号，并将数据缓存于本地；通过进入系统时，与服务器比较版本号是否一致，从而判断是否重新缓存相应的数据。

### 存储介质区分

- 内存缓存: 数据常驻内存，高速并发访问，读写高效简单；宕机或者服务重启会丢失数据

- 持久化缓存: 数据写入到磁盘里，读写性能较低，容量更大

### 架构层次区分

- 页面缓存
- 浏览器缓存
- 反向代理缓存
- 应用级缓存

## 缓存使用模式

### Cache-Aside

- 业务代码中管理维护缓存

1. 先从缓存中读取数据，没有命中，则回源到存储系统，取出数据放入缓存；
2. 将数据写入到存储系统，写入成功将缓存数据过期，下次读取在加载缓存数据

#### 可引发的问题

- 对于高频繁、高并发的业务，将缓存数据过期，并未进行加载数据的期间，会引发大量请求直接请求数据存储系统；
    答: 可进行加锁处理，等待缓存数据写入成功，再进行读取

- 缓存数据写入失败，可以发起重试


### Read-Through

- 先访问缓存，没有数据则从数据库加载，放入缓存

### Refresh-Ahead

- 仅从缓存取数据；设定数据的过期时间，通过订阅过期key的事件，自动从数据库重新加载数据；可能取到非数据库的最新数据

### Write-Through

- 先调用缓存写入，从缓存更新到存储系统
