# 进程与线程相关理论

## 进程与线程的区别

### 系统资源

1. 进程: 受到系统分配资源并可拥有资源的独立单位； 能独立运行，独立调度和分派的基本单位

2. 一个程序可由多个进程组成；进程能是多个程序并发执行, 提供资源利用率和系统吞吐量

3. 线程不拥有资源；可访问其进程拥有的资源

4. 进程切换的系统开销比线程切换大

### 通信

1. 进程之间需要使用IPC通信(管道、 消息队列、 信号量与共享内存、 Socket)

2. 线程间通信: 同步通信方式-互斥锁、条件变量与信号量

### 从属关系

1. 一个进程至少由一个线程组成


## 进程间的通信方式

### 管道

1. 一种半双工的工作方式，也就是说数据只能沿着管道的一个方向进行传递，不可以在同一个管道上反向传数据

举例：`ps -aux|grep php` ps进程和grep进程两个进程之间用|完成了通信

2. 管道分为未命名和命名管道：`未命名管道`只能在拥有公共祖先的两个进程之间使用，只能用于父进程和和其子进程之间的通信；`命名管道`则可以用于任何两个毫无关连的进程之间的通信

3. PHP里使用`posix_mkfifo()`配置指定路径作为创建管道文件，进程通过对文件实现数据写入与读取来完成通信流程

### 消息队列

1. 存储于系统内核中（不是用户态），一般我们外部程序使用一个key来对消息队列进行读写操作。

2. PHP里通过msg_*系列函数完成消息队列操作的

### 信号量与共享内存

1. 共享内存是最快是进程间通信方式，直接操控同一份数据。信号量作为一种锁机制，防止多个进程进行读写操作发生不同步问题

2. 信号量的使用原理与流程：
    - 如果信号量大于0，那么就表示这块儿共享资源可以使用，然后进程将信号量减1
    - 如果信号量为0，则进程进入休眠状态一直到信号量大于0，进程唤醒开始从1
    - 信号量的检测并且减1是原子性的；由系统内核来实现的。

3. PHP里sem_*是信号量相关函数，shm_*是共享内存相关函数

## 同步 异步 阻塞 非阻塞

- 异步：执行操作后立即结束，响应会通知执行者。调用结果不会直接返回

- 阻塞与非阻塞

1. 对临界区的公共资源或共享数据竞态访问的角度进行区分
2. 阻塞: 共享资源被占用，只能等待
3. 非阻塞: 不等待立即返回，期待进行重试

## Linux服务的进程相关使用

- Redis 单进程单线程
- Nginx 多进程单线程

它们都使用多路IO复用实现(并发事件驱动)来处理高并发请求

## 进程调度

调度算法三大类：批处理中的调度、交互系统中的调度、实时系统中的调度

### 批处理中的调度

#### 先来先服务 (first-come first-serverd [FCFS])

- 属于非抢占式的进程调度；每个进程任务被放置于就绪进程等待队列里（单链表数据结构）
- 无法实现进程任务的优先级；耗时任务无法得到优先消费情况

#### 最短作业优先(Shortest Job First [SJF])

- 属于非抢占式的进程调度；
- 对处理任务按照运行时间进行升序排序；按照顺序, 优先处理耗时短任务；

#### 最短剩余时间优先(Shortest Remaining Time Next [SRT])

- 抢占式进程调度
- 优先选择剩余运行时间最短的那个进程运行；容易将当前的进程挂起, 优先处理短期的进程任务

### 交互式系统的调度

#### 轮询调度(round robin)

- 每个进程都会被分配一个时间段，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换

#### 优先级调度(priority scheduling)

- 每个进程都被赋予一个优先级，优先级高的进程优先运行。
- 调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。


## 并行 与 并发

1. 并行的"同时"是同一时刻可以多个进程在运行(处于running)，并发的"同时"是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象

2. 并行与否程序员无法控制，只能让操作系统决定。

### 并行和串行

串行：一次只能取得一个任务并执行这一个任务

并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务

#### 注意点

1. 如果是单进程/单线程的并行，那么效率比串行更差
2. 如果只有单核cpu，多进程并行并没有提高效率
3. 从任务队列上看，由于同时从队列中取得多个任务并执行，相当于将一个长任务队列变成了短队列

### 并发

并发是一种现象：同时运行多个程序或多个任务需要被处理的现象；可能是并行执行的，也可能是串行执行的，和CPU核心数无关，是操作系统进程调度和CPU上下文切换达到的结果

#### 解决大并发的一个思路是将大任务分解成多个小任务：

1. 可能要使用一些数据结构来避免切分成多个小任务带来的问题
2. 可以多进程/多线程并行的方式去执行这些小任务达到高效率
3. 或者以单进程/单线程配合多路复用执行这些小任务来达到高效率

## 内核线程、轻量级进程、用户线程

### 内核线程

内核作为处理异步事件；使用资源：内核栈与上下文切换保存空间

### 轻量线程

由内核支持的用户线程；是独立的线程调度单元；

当某一线程处于阻塞，不会影响整个进程的执行；

相关操作都需要进行系统调用(用户与内核进行切换，消耗内核资源)

### 用户线程

完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的

用户线程之间的调度由在用户空间实现的线程库实现；用户线程如果阻塞在系统调用中，则整个进程都将会阻塞

#### 加强用户线程

利用内核支持的轻量进程，实现用户线程和内核线程之间的桥梁；当内核调度到某个轻量线程上时，此时与该轻量线程关联的用户线程就被执行

用户线程的系统调用要通过轻量线程，并且某个用户线程阻塞，不会影响整个进程执行


