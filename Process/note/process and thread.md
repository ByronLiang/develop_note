# 进程与线程相关理论

## 进程间的通信方式

### 管道

1. 一种半双工的工作方式，也就是说数据只能沿着管道的一个方向进行传递，不可以在同一个管道上反向传数据

举例：`ps -aux|grep php` ps进程和grep进程两个进程之间用|完成了通信

2. 管道分为未命名和命名管道：`未命名管道`只能在拥有公共祖先的两个进程之间使用，只能用于父进程和和其子进程之间的通信；`命名管道`则可以用于任何两个毫无关连的进程之间的通信

3. PHP里使用`posix_mkfifo()`配置指定路径作为创建管道文件，进程通过对文件实现数据写入与读取来完成通信流程

### 消息队列

1. 存储于系统内核中（不是用户态），一般我们外部程序使用一个key来对消息队列进行读写操作。

2. PHP里通过msg_*系列函数完成消息队列操作的

### 信号量与共享内存

1. 共享内存是最快是进程间通信方式，直接操控同一份数据。信号量作为一种锁机制，防止多个进程进行读写操作发生不同步问题

2. 信号量的使用原理与流程：
    - 如果信号量大于0，那么就表示这块儿共享资源可以使用，然后进程将信号量减1
    - 如果信号量为0，则进程进入休眠状态一直到信号量大于0，进程唤醒开始从1
    - 信号量的检测并且减1是原子性的；由系统内核来实现的。

3. PHP里sem_*是信号量相关函数，shm_*是共享内存相关函数

## 同步 异步 阻塞 非阻塞

- 异步：执行操作后立即结束，响应会通知执行者。调用结果不会直接返回

- 阻塞与非阻塞

1. 对临界区的公共资源或共享数据竞态访问的角度进行区分
2. 阻塞: 共享资源被占用，只能等待
3. 非阻塞: 不等待立即返回，期待进行重试

## Linux服务的进程相关使用

- Redis 单进程单线程
- Nginx 多进程单线程

它们都使用多路IO复用实现(并发事件驱动)来处理高并发请求

## 进程调度

调度算法三大类：批处理中的调度、交互系统中的调度、实时系统中的调度

### 批处理中的调度

#### 先来先服务 (first-come first-serverd [FCFS])

- 属于非抢占式的进程调度；每个进程任务被放置于就绪进程等待队列里（单链表数据结构）
- 无法实现进程任务的优先级；耗时任务无法得到优先消费情况

#### 最短作业优先(Shortest Job First [SJF])

- 属于非抢占式的进程调度；
- 对处理任务按照运行时间进行升序排序；按照顺序, 优先处理耗时短任务；

#### 最短剩余时间优先(Shortest Remaining Time Next [SRT])

- 抢占式进程调度
- 优先选择剩余运行时间最短的那个进程运行；容易将当前的进程挂起, 优先处理短期的进程任务

### 交互式系统的调度

#### 轮询调度(round robin)

- 每个进程都会被分配一个时间段，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换

#### 优先级调度(priority scheduling)

- 每个进程都被赋予一个优先级，优先级高的进程优先运行。
- 调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。

