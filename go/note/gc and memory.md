# 内存管理与垃圾回收记录

## 内存管理

### 小对象与大对象界定

小对象: 对象所占用内存小于等于32kb; 分配内存的位置是per-P 上分配 `(单个goroutine分配的线程空间，不存在并发)`

大对象: 内存占用大于32kb; 分配在堆上

对于频繁使用到大量的小对象，请使用小对象内存池，避免因为不断的gc造成的性能问题

### 引发大堆主要因素

当使用的类型，其底层包含指针, 都会从堆申请并占用内存；当存储的数量很大时，会诱发`large heaps` 大堆，从而耗费大量资源进行gc

1. 大量字符串类型 (string)

2. 使用`time.Time` 作为对象里的时间戳

3. Map里的value是切片(slice)类型

### 代码优化gc

#### 减少string类型使用

1. 对短小文本内容，可考虑使用const 声明

2. 针对日期与时间戳, 尽量不使用字符串形式的日期, 使用int整型数据类型作为时间戳

#### 基本优化

1. 减少对象分配；尽量做到，对象的重用

```go
// 没有注入形参 每次开辟新的切片返回数据
func(r *Reader)Read() ([]byte, error)
// 复用原形参地址内存 避免开辟/回收临时的地址内存数据
func(r *Reader)Read(tar []byte) (int, error)
```

2. 不使用+拼接string 由于采用+来进行string的连接会生成新的对象，降低gc的效率;

3. append操作：正确预估数组的长度的话，最初分配空间做好空间规划操作，有效降低gc的压力，提升代码的效率

4. 尽量做到从系统申请内存，而不是从heap里，从而减轻gc；(zero-copy 零拷贝, mmp 内存地址映射)

### 对象池针对大内存对象回收

若对象池的对象里含有字节切片数据结构(`[]byte`)，内存申请波动较大的数据结构，若从对象池回收大体积字节切片对象，会不断增长内存占用

一般，对象池适用于固定内存对象，或者设定回收对象的最大内存值，避免回收对象是一个大内存对象。

#### 案例

1. 参考 `fmt` 库的 `Sprint` 方法, 使用 `sync.Pool 池话且其对象含有 []byte 结构` 对象输出重组字符内容

2. 官方讨论: [add a hard limit on the maximum buffer to place back in the pool](https://golang.org/issue/23199)
