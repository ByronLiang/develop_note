# Golang 锁应用

## 自旋锁与互斥锁背景

### 应用背景

互斥锁用于临界区持锁时间比较长的操作: 业务复杂；单核处理器

自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况

### 总结

1. 自旋锁与互斥锁都是为了实现保护资源共享的机制。
2. 无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。
3. 获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。

## 互斥锁

1.互斥锁有两种操作，获取锁和释放锁
2.当有一个goroutine获取了互斥锁后，任何goroutine都不可以获取互斥锁，只能等待这个goroutine将互斥锁释放
3.互斥锁适用于读写操作数量差不多的情况

### Mutex设计细节

结构体由两个成员组成：state, sema; 都是32位整型

加锁与解锁都具备原子性与CAS；属于位操作，对指定数位进行值变更

利用位数, 记录等待排队数；增减等待排队数

#### state
   
1. 最低一位 `MutexLocked`: 是否已经被一个协程持有(是否上锁)；

2. 最低第二位`MutexWoken`: 当前执行唤醒操作时只会唤醒一个协程，且如果已有唤醒的协程就不会再执行唤醒操作了。

3. 最低第三位`MutexStarving`: 标记当前模式, 默认是普通模式，当等待锁的请求达到一定数量，将变成饥饿模式

4. 剩余位数，存放当前等待锁的协程数量

#### sema

等待队列的信号量，sema是个先进先出的队列，用来阻塞、唤醒协程

#### 设计

正常状态有高效性能，优先满足在CPU 运行的goroutine；饥饿模式能阻止尾部延迟的现象，及时消费等待队列里goroutinue

#### 正常模式

1. 新请求锁的goroutine 具有自旋机制(spin), 进行一定次数的检测锁是否被释放

2. 当锁被释放，会优先把锁赋予新请求锁的goroutine，因为此goroutinue 正在 CPU 上执行，若赋予给等待队列里的首位goroutinue，需要进行调度，使其在 CPU 上执行。效率会不理想

3. 当等待队列里最前面的goroutinue 已等待超过 1ms，锁会切换为饥饿模式

#### 饥饿模式

1. 新请求锁的goroutine 不执行自旋机制，直接在等待队列尾部

2. 每当锁被释放，等待队列按照FIFO顺序赋予锁

3. 当等待队列完全消费完 或者 等待队列里的等待时长小于1ms，锁会切换为正常模式

## 读写锁

`sync.RWMutex`

1.读写锁有四种操作 读上锁 读解锁 写上锁 写解锁
2.写锁最多有一个，读锁可以有多个; 写锁的优先级高于读锁
3.一个goroutine获得写锁时，其他goroutine不可以获得读锁/写锁，需要等待写锁释放
5.一个goroutine获得读锁时，其他goroutine可以获得读锁，不能获得写锁; (写锁的优先级高于读锁, 有效避免长时间阻塞情况)
6.读写锁适用于读多写少的情景

## 使用总结

1.在单纯的只是获取锁和释放锁时，互斥锁的用时要少一些，这主要是因为多个线程同时获取读写锁的情况比较少出现
2.golang底层实现上，互斥锁确实要比读写锁的性能要好一些，这主要是因为读写锁的底层实现其实是互斥锁加上计数器
3.在增强协程互相冲突的效果后，读写锁的性能要明显高于互斥锁。

## 锁设计思考

可以参考 Java 的 `AQS 设计原理` 

- 线程调度与睡眠(阻塞)
- 内存屏障隔离
- 队列排队 锁释放与分配
- 原子性计数，二进制位数
