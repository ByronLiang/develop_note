# 协程 与 通道 笔记

## chan 底层

一个环形队列和两个链表展开

## chan关闭后相关操作现象

1. 写操作: 会引发异常
2. 读操作: 

- 如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会`非阻塞`直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。

- chan 关闭后，并被赋值为`nil`，则接收值操作会一直处于`阻塞`；(原理: 将当前chan 进行未初始化处理)

```go

// 未初始化chan
// 读写都会产生阻塞
var cc chan int

// 已初始化chan
c := make(chan int)

```

## GMP调度模式

### G

1. Goroutine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销

2. g0是具备调度栈的协程，深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行

### M

在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销;

### P

调度器中的处理器 P 是线程`(M)`和 Goroutine`(G)`的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。

