# 协程 与 通道 笔记

## chan 底层

一个环形队列和两个链表展开

等待队列使用双向链表，存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表

### chan 收发规则

Channel 收发操作均遵循了先入先出（FIFO）的设计

1. 先从 Channel 读取数据的 Goroutine 会先接收到数据

2. 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利

## chan关闭后相关操作现象

1. 写操作: 会引发异常
2. 读操作: 

- 如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会`非阻塞`直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。

- chan 关闭后，并被赋值为`nil`，则接收值操作会一直处于`阻塞`；(原理: 将当前chan 进行未初始化处理)

```go

// 未初始化chan
// 读写都会产生阻塞
var cc chan int

// 已初始化chan
c := make(chan int)

```

## Go协程

### 内存管理

1. 新建立一个Go协程, 会向堆申请内存, 协程的初始栈的大小是`2KB`, 是一个连续栈；可以进行扩容与缩容: 扩容最大限度为1GB; 缩容不会低于2KB;

2. 使用连续栈机制时，栈空间不足会进行扩容; 

3. 扩容流程: 
    - 调用用runtime.newstack在内存空间中分配更大的栈内存空间；
    - 使用runtime.copystack将旧栈中的所有内容复制到新的栈中；
    - 将指向旧栈对应变量的指针重新指向新栈；
    - 调用runtime.stackfree销毁并回收旧栈的内存空间；

4. 缩容流程: 涉及垃圾回收, 新旧栈拷贝等流程

#### 总结

1. 频繁创建与销毁go协程, 都需要进行相关内存的申请与回收

### GMP调度模式

最多能创建10000个M(线程), 但能够使用在用户应用的数量是基于`GOMAXPROCS`参数；超出参数数量的线程属于系统调用

M的数量可以超过P的数量; P的数量是是基于`GOMAXPROCS`参数

#### G

1. Goroutine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销

2. g0是具备调度栈的协程，深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行

#### M

在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销;

#### P

调度器中的处理器 P 是线程`(M)`和 Goroutine`(G)`的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。

### Go协程调度模式理解

1. 多处理器系统中, 会有多个逻辑调度器(P), 实现多个线程(G&M组合)并行执行;

2. 传统的线程切换(从一个线程切换到另一线程)，需要从用户态转到内核态进行; 因为线程调度和管理是在内核实现的, 系统开销大; 

而GMP模式下, 在用户态下的P能进行线程调度与管理，无需依赖内核进行线程调度, 令Goroutine的调度更高效;

3. 一个go协程内部，再创建一个或多个go协程。协程都是互相独立的，没有依赖（父子）关系。main函数本身也运行在一个goroutine中，main是所有协程的被依赖者，这里是个特例

#### Go协程与抢占式信号

场景：单核CPU，运行两个Go协程, 其中一个协程，处于死循环；

- 对于Go1.14版本之前, 会因处于死循环的goroutine长期占用, 导致另一goroutine处于阻塞

- 对于Go1.14版本之后, 加入`sysmon`：创建一个独立的 M 作为监控线程，系统级的daemon线程, 无需分配P(处理器)

#### sysmon作用
  
1. 调度执行长时间未执行的timer;

2. netpoller（轮询网络操作）与syscall（系统命令调用）

3. 抢占长时间运行的goroutine

4. 强制执行GC
