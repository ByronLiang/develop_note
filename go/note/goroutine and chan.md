# 协程 与 通道 笔记

## chan 底层

一个环形队列和两个链表展开

等待队列使用双向链表，存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表

### chan 收发规则

Channel 收发操作均遵循了先入先出（FIFO）的设计

1. 先从 Channel 读取数据的 Goroutine 会先接收到数据

2. 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利

## chan关闭后相关操作现象

1. 写操作: 会引发异常
2. 读操作: 

- 如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会`非阻塞`直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。

- chan 关闭后，并被赋值为`nil`，则接收值操作会一直处于`阻塞`；(原理: 将当前chan 进行未初始化处理)

```go

// 未初始化chan
// 读写都会产生阻塞
var cc chan int

// 已初始化chan
c := make(chan int)

```

## GMP调度模式

### G

1. Goroutine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销

2. g0是具备调度栈的协程，深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行

### M

在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销;

### P

调度器中的处理器 P 是线程`(M)`和 Goroutine`(G)`的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。

## 调度模式理解

1. 多处理器系统中, 会有多个逻辑调度器(P), 实现多个线程(G&M组合)并行执行;

2. 传统的线程切换(从一个线程切换到另一线程)，需要从用户态转到内核态进行; 因为线程调度和管理是在内核实现的, 系统开销大; 

而GMP模式下, 在用户态下的P能进行线程调度与管理，无需依赖内核进行线程调度, 令Goroutine的调度更高效;

